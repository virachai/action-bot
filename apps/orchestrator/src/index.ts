import { config } from '@repo/config';
import { WorkflowState, WorkflowJob, WorkflowError } from '@repo/types';
import { S3Service } from './services/s3.service.js';
import { AILogicService } from './services/ai-logic.service.js';
import { VideoEngineService } from './services/video-engine.service.js';

/**
 * Workflow Orchestrator
 * Manages the end-to-end video generation pipeline
 */
export class WorkflowOrchestrator {
    private s3Service: S3Service;
    private aiService: AILogicService;
    private videoService: VideoEngineService;

    constructor() {
        this.s3Service = new S3Service();
        this.aiService = new AILogicService(process.env.AI_LOGIC_URL);
        this.videoService = new VideoEngineService(process.env.VIDEO_ENGINE_URL);
    }

    /**
     * Execute the complete video generation workflow
     */
    async executeWorkflow(topic: string): Promise<WorkflowJob> {
        const job: WorkflowJob = {
            id: this.generateId(),
            state: WorkflowState.IDLE,
            topic,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        };

        try {
            console.log(`\nğŸš€ Starting workflow: ${job.id}`);
            console.log(`ğŸ“ Topic: ${topic}\n`);

            // Step 1: Generate script with AI
            job.state = WorkflowState.GENERATING_SCRIPT;
            this.updateJob(job);

            const script = await this.aiService.generateScript({
                topic,
                targetDuration: 60,
                targetPlatforms: ['tiktok', 'instagram', 'youtube'],
                style: 'entertaining',
            });

            job.scriptId = script.id;

            // Save script to S3
            const scriptKey = `scripts/${script.id}.json`;
            await this.s3Service.uploadJson(script, config.s3.buckets.output, scriptKey);
            console.log(`ğŸ’¾ Script saved to S3: ${scriptKey}\n`);

            // Step 2: Download assets (if any external assets are needed)
            job.state = WorkflowState.DOWNLOADING_ASSETS;
            this.updateJob(job);

            // For now, we'll assume assets are already in S3 or generated by video engine

            // Step 3: Assemble video
            job.state = WorkflowState.ASSEMBLING_VIDEO;
            this.updateJob(job);

            const videoMetadata = await this.videoService.generateVideo({
                script,
                outputBucket: config.s3.buckets.output,
                outputKey: `videos/${script.id}.mp4`,
            });

            job.videoId = videoMetadata.id;

            // Step 4: Upload output (already done by video engine)
            job.state = WorkflowState.UPLOADING_OUTPUT;
            this.updateJob(job);

            console.log(`ğŸ“¤ Video uploaded to S3: ${videoMetadata.outputUrl}\n`);

            // Step 5: Complete
            job.state = WorkflowState.COMPLETED;
            this.updateJob(job);

            console.log(`âœ¨ Workflow completed successfully!`);
            console.log(`ğŸ“Š Video Metadata:`);
            console.log(`   - Duration: ${videoMetadata.duration}s`);
            console.log(`   - Size: ${(videoMetadata.fileSize / 1024 / 1024).toFixed(2)} MB`);
            console.log(`   - URL: ${videoMetadata.outputUrl}\n`);

            return job;
        } catch (error) {
            job.state = WorkflowState.FAILED;
            job.error = {
                message: error instanceof Error ? error.message : 'Unknown error',
                stack: error instanceof Error ? error.stack : undefined,
                timestamp: new Date().toISOString(),
            };
            this.updateJob(job);

            console.error(`âŒ Workflow failed: ${job.error.message}\n`);

            throw new WorkflowError(
                `Workflow failed at state ${job.state}`,
                job.state,
                error as Error
            );
        }
    }

    /**
     * Health check all services
     */
    async healthCheck(): Promise<{
        aiLogic: boolean;
        videoEngine: boolean;
        s3: boolean;
    }> {
        const [aiLogic, videoEngine] = await Promise.all([
            this.aiService.healthCheck(),
            this.videoService.healthCheck(),
        ]);

        // Simple S3 health check by listing buckets
        let s3 = false;
        try {
            await this.s3Service.listObjects(config.s3.buckets.output, '');
            s3 = true;
        } catch {
            s3 = false;
        }

        return { aiLogic, videoEngine, s3 };
    }

    /**
     * Update job state
     */
    private updateJob(job: WorkflowJob): void {
        job.updatedAt = new Date().toISOString();
        console.log(`ğŸ“ State: ${job.state}`);
    }

    /**
     * Generate unique ID
     */
    private generateId(): string {
        return `wf_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    }
}

/**
 * Main entry point
 */
async function main() {
    try {
        // Get topic from environment or use default
        const topic = process.env.VIDEO_TOPIC || 'The Future of AI in 2026';

        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘   AUTO-SHORT-FACTORY ORCHESTRATOR     â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

        const orchestrator = new WorkflowOrchestrator();

        // Health check
        console.log('ğŸ” Performing health checks...');
        const health = await orchestrator.healthCheck();
        console.log(`   AI Logic: ${health.aiLogic ? 'âœ…' : 'âŒ'}`);
        console.log(`   Video Engine: ${health.videoEngine ? 'âœ…' : 'âŒ'}`);
        console.log(`   S3: ${health.s3 ? 'âœ…' : 'âŒ'}\n`);

        if (!health.aiLogic || !health.videoEngine || !health.s3) {
            console.error('âš ï¸  Some services are unavailable. Please check configuration.\n');
            process.exit(1);
        }

        // Execute workflow
        await orchestrator.executeWorkflow(topic);

        console.log('ğŸ‘‹ Orchestrator finished successfully!\n');
        process.exit(0);
    } catch (error) {
        console.error('ğŸ’¥ Fatal error:', error);
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}

export { WorkflowOrchestrator };
